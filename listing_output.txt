; IMPORTANT: Addresses 000000..000005 are machine-reserved. We set LOC 6.
              LOC 6
000006 026131 JMA START
              READ_TARGET:
000007 002370     LDR 0,ZERO      ; result
000010 002770     LDR 1,ZERO      ; signFlag (1 if '-')
000011 003370     LDR 2,ZERO      ; seenDigit
              RT_LOOP:
000012 143400     IN 3,0
000013 005766     STR 3,READBUF
    ; If no digit yet, allow leading '-'
000014 021022     JZ 2,RT_CHECK_SIGN
              RT_DIGIT_CHECK:
000015 003766     LDR 3,READBUF
000016 013757     SMR 3,ASCII_0
000017 037431     JGE 3,RT_GE_ZERO
    ; Not a digit: if no digit yet, keep scanning; else finalize
000020 021012     JZ 2,RT_LOOP
000021 026051     JMA RT_DONE
              RT_CHECK_SIGN:
000022 003766     LDR 3,READBUF
000023 013760     SMR 3,ASCII_MINUS
000024 021426     JZ 3,RT_SET_NEG
000025 026015     JMA RT_DIGIT_CHECK
              RT_SET_NEG:
000026 002770     LDR 1,ZERO
000027 014401     AIR 1,1
000030 026012     JMA RT_LOOP
              RT_GE_ZERO:
000031 017412     SIR 3,10
000032 037450     JGE 3,RT_NOT_DIGIT
000033 015412     AIR 3,10
    ; seenDigit = 1
000034 003370     LDR 2,ZERO
000035 015001     AIR 2,1
    ; Accumulate: R0 = R0*10 + digit (x10 via 8+2)
000036 005767     STR 3,PRINT_TMP
000037 004366     STR 0,READBUF
000040 002366     LDR 0,READBUF
000041 062301     SRC 0,1,1,1
000042 004361     STR 0,TEMP_DIFF
000043 002366     LDR 0,READBUF
000044 062303     SRC 0,3,1,1
000045 010361     AMR 0,TEMP_DIFF
000046 010367     AMR 0,PRINT_TMP
000047 026012     JMA RT_LOOP
              RT_NOT_DIGIT:
000050 021012     JZ 2,RT_LOOP
              RT_DONE:
    ; Apply sign
000051 020454     JZ 1,RT_POS
000052 172000     NOT 0
000053 014001     AIR 0,1
              RT_POS:
000054 004365     STR 0,TARGET
000055 026132     JMA AFTER_TARGET

; Parser for a candidate: stores into READVAL then jumps to AFTER_CAND
              READ_CAND:
000056 002370     LDR 0,ZERO      ; result
000057 002770     LDR 1,ZERO      ; signFlag
000060 003370     LDR 2,ZERO      ; seenDigit
              RC_LOOP:
000061 143400     IN 3,0
000062 005766     STR 3,READBUF
000063 021071     JZ 2,RC_CHECK_SIGN
              RC_DIGIT_CHECK:
000064 003766     LDR 3,READBUF
000065 013757     SMR 3,ASCII_0
000066 037500     JGE 3,RC_GE_ZERO
000067 021061     JZ 2,RC_LOOP
000070 026120     JMA RC_DONE
              RC_CHECK_SIGN:
000071 003766     LDR 3,READBUF
000072 013760     SMR 3,ASCII_MINUS
000073 021475     JZ 3,RC_SET_NEG
000074 026064     JMA RC_DIGIT_CHECK
              RC_SET_NEG:
000075 002770     LDR 1,ZERO
000076 014401     AIR 1,1
000077 026061     JMA RC_LOOP
              RC_GE_ZERO:
000100 017412     SIR 3,10
000101 037517     JGE 3,RC_NOT_DIGIT
000102 015412     AIR 3,10
000103 003370     LDR 2,ZERO
000104 015001     AIR 2,1
000105 005767     STR 3,PRINT_TMP
000106 004366     STR 0,READBUF
000107 002366     LDR 0,READBUF
000110 062301     SRC 0,1,1,1
000111 004361     STR 0,TEMP_DIFF
000112 002366     LDR 0,READBUF
000113 062303     SRC 0,3,1,1
000114 010361     AMR 0,TEMP_DIFF
000115 010367     AMR 0,PRINT_TMP
000116 026061     JMA RC_LOOP
              RC_NOT_DIGIT:
000117 021061     JZ 2,RC_LOOP
              RC_DONE:
000120 020523     JZ 1,RC_POS
000121 172000     NOT 0
000122 014001     AIR 0,1
              RC_POS:
000123 004371     STR 0,READVAL
    ; Dispatch return based on MODE: 1 -> first-candidate init, 0 -> loop
000124 003373     LDR 2,MODE
000125 021160     JZ 2,AFTER_CAND_LOOP
    ; MODE==1 -> clear MODE and go to first-candidate return
000126 003370     LDR 2,ZERO
000127 005373     STR 2,MODE
000130 026136     JMA AFTER_CAND_FIRST

; === Main ===
              START:
    ; Read TARGET first
000131 026007     JMA READ_TARGET
              AFTER_TARGET:

    ; Read first candidate -> initialize WINNER/MIN_DIFF
    ; Indicate first-candidate return path via MODE=1
000132 003370     LDR 2,ZERO
000133 015001     AIR 2,1
000134 005373     STR 2,MODE
000135 026056     JMA READ_CAND
              AFTER_CAND_FIRST:
000136 002371     LDR 0,READVAL
000137 004363     STR 0,WINNER
000140 002363     LDR 0,WINNER
000141 012365     SMR 0,TARGET
000142 036145     JGE 0,MINPOS0
000143 172000     NOT 0
000144 014001     AIR 0,1
              MINPOS0:
000145 004362     STR 0,MIN_DIFF

    ; Set CNT = 19 remaining (since we already processed 1st)
000146 003370     LDR 2,ZERO
000147 015023     AIR 2,19
000150 005364     STR 2,CNT

; Loop remaining 19 candidates
              CAND_LOOP:
000151 003364     LDR 2,CNT
000152 021201     JZ 2,COMP_DONE
000153 017001     SIR 2,1
000154 005364     STR 2,CNT

    ; Ensure MODE=0 for loop returns
000155 003370     LDR 2,ZERO
000156 005373     STR 2,MODE
000157 026056     JMA READ_CAND
              AFTER_CAND_LOOP:
000160 002371     LDR 0,READVAL
000161 004367     STR 0,PRINT_TMP

    ; diff = |cand - TARGET|
000162 002367     LDR 0,PRINT_TMP
000163 012365     SMR 0,TARGET
000164 036167     JGE 0,DIFFPOS
000165 172000     NOT 0
000166 014001     AIR 0,1
              DIFFPOS:
000167 004361     STR 0,TEMP_DIFF

    ; if diff < MIN_DIFF -> update MIN_DIFF and WINNER
000170 002762     LDR 1,MIN_DIFF
000171 003361     LDR 2,TEMP_DIFF
000172 013362     SMR 2,MIN_DIFF
000173 037200     JGE 2,NO_UPD
000174 003361     LDR 2,TEMP_DIFF
000175 005362     STR 2,MIN_DIFF
000176 003767     LDR 3,PRINT_TMP
000177 005763     STR 3,WINNER
              NO_UPD:
000200 026151     JMA CAND_LOOP

; Print WINNER as multi-digit decimal with sign
              COMP_DONE:
    ; R1 holds |WINNER|, R2=pow, R0 temp
000201 002363     LDR 0,WINNER
000202 036211     JGE 0,PW_ABS
000203 003760     LDR 3,ASCII_MINUS
000204 145401     OUT 3,1
000205 002763     LDR 1,WINNER
000206 172400     NOT 1
000207 014401     AIR 1,1
000210 026212     JMA PW_ZCHK
              PW_ABS:
000211 002763     LDR 1,WINNER
              PW_ZCHK:
000212 012770     SMR 1,ZERO
000213 022617     JNE 1,PW_FINDPOW
000214 003757     LDR 3,ASCII_0
000215 145401     OUT 3,1
000216 000000     HLT

; Find highest power of 10 without overflow: tmp=R1; pow=1; while (tmp>=10) {tmp/=10; pow*=10}
              PW_FINDPOW:
000217 003370     LDR 2,ZERO
000220 015001     AIR 2,1
000221 004766     STR 1,READBUF
              PW_POW_LOOP:
000222 002366     LDR 0,READBUF
000223 016012     SIR 0,10
000224 036226     JGE 0,PW_POW_STEP
000225 026245     JMA PW_PRINT
              PW_POW_STEP:
000226 002366     LDR 0,READBUF
000227 003770     LDR 3,ZERO
000230 015412     AIR 3,10
000231 162300     DVD 0,3
000232 004366     STR 0,READBUF
000233 005367     STR 2,PRINT_TMP
000234 002367     LDR 0,PRINT_TMP
000235 062301     SRC 0,1,1,1
000236 004361     STR 0,TEMP_DIFF
000237 002367     LDR 0,PRINT_TMP
000240 062303     SRC 0,3,1,1
000241 010361     AMR 0,TEMP_DIFF
000242 004367     STR 0,PRINT_TMP
000243 003367     LDR 2,PRINT_TMP
000244 026222     JMA PW_POW_LOOP

              PW_PRINT:
              PW_PRINT_LOOP:
000245 005367     STR 2,PRINT_TMP
000246 004766     STR 1,READBUF
000247 002366     LDR 0,READBUF
000250 003367     LDR 2,PRINT_TMP
000251 162200     DVD 0,2
000252 004361     STR 0,TEMP_DIFF
000253 005366     STR 2,READBUF
000254 002766     LDR 1,READBUF
000255 003367     LDR 2,PRINT_TMP
000256 002370     LDR 0,ZERO
000257 014012     AIR 0,10
000260 163000     DVD 2,0
000261 002361     LDR 0,TEMP_DIFF
000262 004367     STR 0,PRINT_TMP
000263 003757     LDR 3,ASCII_0
000264 011767     AMR 3,PRINT_TMP
000265 145401     OUT 3,1
000266 013370     SMR 2,ZERO
000267 023245     JNE 2,PW_PRINT_LOOP
000270 000000     HLT

; --- Data ---
              LOC 239
000357 000060 ASCII_0:     DATA 48
000360 000055 ASCII_MINUS: DATA 45
000361 000000 TEMP_DIFF:    DATA 0
000362 000000 MIN_DIFF:     DATA 0
000363 000000 WINNER:       DATA 0
000364 000000 CNT:          DATA 0
000365 000000 TARGET:       DATA 0
000366 000000 READBUF:      DATA 0
000367 000000 PRINT_TMP:    DATA 0
000370 000000 ZERO:         DATA 0
000371 000000 READVAL:      DATA 0
000372 000000 LINK_SAVE:    DATA 0
000373 000000 MODE:         DATA 0

; End
